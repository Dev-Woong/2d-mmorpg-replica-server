// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class C_CharacterListRequest;
struct C_CharacterListRequestDefaultTypeInternal;
extern C_CharacterListRequestDefaultTypeInternal _C_CharacterListRequest_default_instance_;
class C_CreateCharacterRequest;
struct C_CreateCharacterRequestDefaultTypeInternal;
extern C_CreateCharacterRequestDefaultTypeInternal _C_CreateCharacterRequest_default_instance_;
class C_JwtLoginRequest;
struct C_JwtLoginRequestDefaultTypeInternal;
extern C_JwtLoginRequestDefaultTypeInternal _C_JwtLoginRequest_default_instance_;
class C_PlayerMoveRequest;
struct C_PlayerMoveRequestDefaultTypeInternal;
extern C_PlayerMoveRequestDefaultTypeInternal _C_PlayerMoveRequest_default_instance_;
class CharacterSummaryInfo;
struct CharacterSummaryInfoDefaultTypeInternal;
extern CharacterSummaryInfoDefaultTypeInternal _CharacterSummaryInfo_default_instance_;
class PlayerMoveInfo;
struct PlayerMoveInfoDefaultTypeInternal;
extern PlayerMoveInfoDefaultTypeInternal _PlayerMoveInfo_default_instance_;
class S_BroadcastPlayerMove;
struct S_BroadcastPlayerMoveDefaultTypeInternal;
extern S_BroadcastPlayerMoveDefaultTypeInternal _S_BroadcastPlayerMove_default_instance_;
class S_CharacterListReply;
struct S_CharacterListReplyDefaultTypeInternal;
extern S_CharacterListReplyDefaultTypeInternal _S_CharacterListReply_default_instance_;
class S_CreateCharacterReply;
struct S_CreateCharacterReplyDefaultTypeInternal;
extern S_CreateCharacterReplyDefaultTypeInternal _S_CreateCharacterReply_default_instance_;
class S_JwtLoginReply;
struct S_JwtLoginReplyDefaultTypeInternal;
extern S_JwtLoginReplyDefaultTypeInternal _S_JwtLoginReply_default_instance_;
class Vector2Info;
struct Vector2InfoDefaultTypeInternal;
extern Vector2InfoDefaultTypeInternal _Vector2Info_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::C_CharacterListRequest* Arena::CreateMaybeMessage<::Protocol::C_CharacterListRequest>(Arena*);
template<> ::Protocol::C_CreateCharacterRequest* Arena::CreateMaybeMessage<::Protocol::C_CreateCharacterRequest>(Arena*);
template<> ::Protocol::C_JwtLoginRequest* Arena::CreateMaybeMessage<::Protocol::C_JwtLoginRequest>(Arena*);
template<> ::Protocol::C_PlayerMoveRequest* Arena::CreateMaybeMessage<::Protocol::C_PlayerMoveRequest>(Arena*);
template<> ::Protocol::CharacterSummaryInfo* Arena::CreateMaybeMessage<::Protocol::CharacterSummaryInfo>(Arena*);
template<> ::Protocol::PlayerMoveInfo* Arena::CreateMaybeMessage<::Protocol::PlayerMoveInfo>(Arena*);
template<> ::Protocol::S_BroadcastPlayerMove* Arena::CreateMaybeMessage<::Protocol::S_BroadcastPlayerMove>(Arena*);
template<> ::Protocol::S_CharacterListReply* Arena::CreateMaybeMessage<::Protocol::S_CharacterListReply>(Arena*);
template<> ::Protocol::S_CreateCharacterReply* Arena::CreateMaybeMessage<::Protocol::S_CreateCharacterReply>(Arena*);
template<> ::Protocol::S_JwtLoginReply* Arena::CreateMaybeMessage<::Protocol::S_JwtLoginReply>(Arena*);
template<> ::Protocol::Vector2Info* Arena::CreateMaybeMessage<::Protocol::Vector2Info>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

enum MsgId : int {
  C_JWT_LOGIN_REQUEST = 0,
  S_JWT_LOGIN_REPLY = 1,
  C_CREATE_CHARACTER_REQUEST = 2,
  S_CREATE_CHARACTER_REPLY = 3,
  C_CHARACTER_LIST_REQUEST = 4,
  S_CHARACTER_LIST_REPLY = 5,
  C_PLAYER_MOVE_REQUEST = 6,
  S_BROADCAST_PLAYER_MOVE = 7,
  MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MsgId_IsValid(int value);
constexpr MsgId MsgId_MIN = C_JWT_LOGIN_REQUEST;
constexpr MsgId MsgId_MAX = S_BROADCAST_PLAYER_MOVE;
constexpr int MsgId_ARRAYSIZE = MsgId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgId_descriptor();
template<typename T>
inline const std::string& MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgId_descriptor(), enum_t_value);
}
inline bool MsgId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgId>(
    MsgId_descriptor(), name, value);
}
enum ELoginResult : int {
  SUCCESS = 0,
  INVALID_TOKEN = 1,
  TOKEN_EXPIRED = 2,
  SERVER_ERROR = 3,
  ELoginResult_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ELoginResult_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ELoginResult_IsValid(int value);
constexpr ELoginResult ELoginResult_MIN = SUCCESS;
constexpr ELoginResult ELoginResult_MAX = SERVER_ERROR;
constexpr int ELoginResult_ARRAYSIZE = ELoginResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELoginResult_descriptor();
template<typename T>
inline const std::string& ELoginResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELoginResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELoginResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELoginResult_descriptor(), enum_t_value);
}
inline bool ELoginResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELoginResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELoginResult>(
    ELoginResult_descriptor(), name, value);
}
enum EGender : int {
  GENDER_NONE = 0,
  GENDER_MALE = 1,
  GENDER_FEMALE = 2,
  EGender_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EGender_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EGender_IsValid(int value);
constexpr EGender EGender_MIN = GENDER_NONE;
constexpr EGender EGender_MAX = GENDER_FEMALE;
constexpr int EGender_ARRAYSIZE = EGender_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGender_descriptor();
template<typename T>
inline const std::string& EGender_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGender>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGender_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGender_descriptor(), enum_t_value);
}
inline bool EGender_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EGender* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGender>(
    EGender_descriptor(), name, value);
}
enum ERegion : int {
  REGION_NONE = 0,
  REGION_GO = 1,
  REGION_BACK = 2,
  ERegion_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ERegion_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ERegion_IsValid(int value);
constexpr ERegion ERegion_MIN = REGION_NONE;
constexpr ERegion ERegion_MAX = REGION_BACK;
constexpr int ERegion_ARRAYSIZE = ERegion_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ERegion_descriptor();
template<typename T>
inline const std::string& ERegion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ERegion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ERegion_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ERegion_descriptor(), enum_t_value);
}
inline bool ERegion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ERegion* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ERegion>(
    ERegion_descriptor(), name, value);
}
enum EDirection : int {
  DIR_UP = 0,
  DIR_DOWN = 1,
  DIR_LEFT = 2,
  DIR_RIGHT = 3,
  EDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EDirection_IsValid(int value);
constexpr EDirection EDirection_MIN = DIR_UP;
constexpr EDirection EDirection_MAX = DIR_RIGHT;
constexpr int EDirection_ARRAYSIZE = EDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EDirection_descriptor();
template<typename T>
inline const std::string& EDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EDirection_descriptor(), enum_t_value);
}
inline bool EDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EDirection>(
    EDirection_descriptor(), name, value);
}
// ===================================================================

class C_JwtLoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_JwtLoginRequest) */ {
 public:
  inline C_JwtLoginRequest() : C_JwtLoginRequest(nullptr) {}
  ~C_JwtLoginRequest() override;
  explicit PROTOBUF_CONSTEXPR C_JwtLoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_JwtLoginRequest(const C_JwtLoginRequest& from);
  C_JwtLoginRequest(C_JwtLoginRequest&& from) noexcept
    : C_JwtLoginRequest() {
    *this = ::std::move(from);
  }

  inline C_JwtLoginRequest& operator=(const C_JwtLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_JwtLoginRequest& operator=(C_JwtLoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_JwtLoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_JwtLoginRequest* internal_default_instance() {
    return reinterpret_cast<const C_JwtLoginRequest*>(
               &_C_JwtLoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(C_JwtLoginRequest& a, C_JwtLoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(C_JwtLoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_JwtLoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_JwtLoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_JwtLoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_JwtLoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_JwtLoginRequest& from) {
    C_JwtLoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_JwtLoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_JwtLoginRequest";
  }
  protected:
  explicit C_JwtLoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessTokenFieldNumber = 1,
  };
  // string accessToken = 1;
  void clear_accesstoken();
  const std::string& accesstoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accesstoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accesstoken();
  PROTOBUF_NODISCARD std::string* release_accesstoken();
  void set_allocated_accesstoken(std::string* accesstoken);
  private:
  const std::string& _internal_accesstoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accesstoken(const std::string& value);
  std::string* _internal_mutable_accesstoken();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_JwtLoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accesstoken_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_JwtLoginReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_JwtLoginReply) */ {
 public:
  inline S_JwtLoginReply() : S_JwtLoginReply(nullptr) {}
  ~S_JwtLoginReply() override;
  explicit PROTOBUF_CONSTEXPR S_JwtLoginReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_JwtLoginReply(const S_JwtLoginReply& from);
  S_JwtLoginReply(S_JwtLoginReply&& from) noexcept
    : S_JwtLoginReply() {
    *this = ::std::move(from);
  }

  inline S_JwtLoginReply& operator=(const S_JwtLoginReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_JwtLoginReply& operator=(S_JwtLoginReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_JwtLoginReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_JwtLoginReply* internal_default_instance() {
    return reinterpret_cast<const S_JwtLoginReply*>(
               &_S_JwtLoginReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(S_JwtLoginReply& a, S_JwtLoginReply& b) {
    a.Swap(&b);
  }
  inline void Swap(S_JwtLoginReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_JwtLoginReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_JwtLoginReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_JwtLoginReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_JwtLoginReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_JwtLoginReply& from) {
    S_JwtLoginReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_JwtLoginReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_JwtLoginReply";
  }
  protected:
  explicit S_JwtLoginReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .Protocol.ELoginResult result = 1;
  void clear_result();
  ::Protocol::ELoginResult result() const;
  void set_result(::Protocol::ELoginResult value);
  private:
  ::Protocol::ELoginResult _internal_result() const;
  void _internal_set_result(::Protocol::ELoginResult value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_JwtLoginReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CreateCharacterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CreateCharacterRequest) */ {
 public:
  inline C_CreateCharacterRequest() : C_CreateCharacterRequest(nullptr) {}
  ~C_CreateCharacterRequest() override;
  explicit PROTOBUF_CONSTEXPR C_CreateCharacterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CreateCharacterRequest(const C_CreateCharacterRequest& from);
  C_CreateCharacterRequest(C_CreateCharacterRequest&& from) noexcept
    : C_CreateCharacterRequest() {
    *this = ::std::move(from);
  }

  inline C_CreateCharacterRequest& operator=(const C_CreateCharacterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CreateCharacterRequest& operator=(C_CreateCharacterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CreateCharacterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CreateCharacterRequest* internal_default_instance() {
    return reinterpret_cast<const C_CreateCharacterRequest*>(
               &_C_CreateCharacterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(C_CreateCharacterRequest& a, C_CreateCharacterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CreateCharacterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CreateCharacterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CreateCharacterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CreateCharacterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CreateCharacterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_CreateCharacterRequest& from) {
    C_CreateCharacterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CreateCharacterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CreateCharacterRequest";
  }
  protected:
  explicit C_CreateCharacterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kGenderFieldNumber = 2,
    kRegionFieldNumber = 3,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // .Protocol.EGender gender = 2;
  void clear_gender();
  ::Protocol::EGender gender() const;
  void set_gender(::Protocol::EGender value);
  private:
  ::Protocol::EGender _internal_gender() const;
  void _internal_set_gender(::Protocol::EGender value);
  public:

  // .Protocol.ERegion region = 3;
  void clear_region();
  ::Protocol::ERegion region() const;
  void set_region(::Protocol::ERegion value);
  private:
  ::Protocol::ERegion _internal_region() const;
  void _internal_set_region(::Protocol::ERegion value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CreateCharacterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    int gender_;
    int region_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CreateCharacterReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CreateCharacterReply) */ {
 public:
  inline S_CreateCharacterReply() : S_CreateCharacterReply(nullptr) {}
  ~S_CreateCharacterReply() override;
  explicit PROTOBUF_CONSTEXPR S_CreateCharacterReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CreateCharacterReply(const S_CreateCharacterReply& from);
  S_CreateCharacterReply(S_CreateCharacterReply&& from) noexcept
    : S_CreateCharacterReply() {
    *this = ::std::move(from);
  }

  inline S_CreateCharacterReply& operator=(const S_CreateCharacterReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CreateCharacterReply& operator=(S_CreateCharacterReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CreateCharacterReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CreateCharacterReply* internal_default_instance() {
    return reinterpret_cast<const S_CreateCharacterReply*>(
               &_S_CreateCharacterReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(S_CreateCharacterReply& a, S_CreateCharacterReply& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CreateCharacterReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CreateCharacterReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CreateCharacterReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CreateCharacterReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CreateCharacterReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CreateCharacterReply& from) {
    S_CreateCharacterReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CreateCharacterReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CreateCharacterReply";
  }
  protected:
  explicit S_CreateCharacterReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string detail = 2;
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_NODISCARD std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CreateCharacterReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CharacterListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_CharacterListRequest) */ {
 public:
  inline C_CharacterListRequest() : C_CharacterListRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_CharacterListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CharacterListRequest(const C_CharacterListRequest& from);
  C_CharacterListRequest(C_CharacterListRequest&& from) noexcept
    : C_CharacterListRequest() {
    *this = ::std::move(from);
  }

  inline C_CharacterListRequest& operator=(const C_CharacterListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CharacterListRequest& operator=(C_CharacterListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CharacterListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CharacterListRequest* internal_default_instance() {
    return reinterpret_cast<const C_CharacterListRequest*>(
               &_C_CharacterListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(C_CharacterListRequest& a, C_CharacterListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CharacterListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CharacterListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CharacterListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CharacterListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_CharacterListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_CharacterListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CharacterListRequest";
  }
  protected:
  explicit C_CharacterListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_CharacterListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CharacterListReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CharacterListReply) */ {
 public:
  inline S_CharacterListReply() : S_CharacterListReply(nullptr) {}
  ~S_CharacterListReply() override;
  explicit PROTOBUF_CONSTEXPR S_CharacterListReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CharacterListReply(const S_CharacterListReply& from);
  S_CharacterListReply(S_CharacterListReply&& from) noexcept
    : S_CharacterListReply() {
    *this = ::std::move(from);
  }

  inline S_CharacterListReply& operator=(const S_CharacterListReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CharacterListReply& operator=(S_CharacterListReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CharacterListReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CharacterListReply* internal_default_instance() {
    return reinterpret_cast<const S_CharacterListReply*>(
               &_S_CharacterListReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(S_CharacterListReply& a, S_CharacterListReply& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CharacterListReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CharacterListReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CharacterListReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CharacterListReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CharacterListReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CharacterListReply& from) {
    S_CharacterListReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CharacterListReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CharacterListReply";
  }
  protected:
  explicit S_CharacterListReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharactersFieldNumber = 1,
  };
  // repeated .Protocol.CharacterSummaryInfo characters = 1;
  int characters_size() const;
  private:
  int _internal_characters_size() const;
  public:
  void clear_characters();
  ::Protocol::CharacterSummaryInfo* mutable_characters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::CharacterSummaryInfo >*
      mutable_characters();
  private:
  const ::Protocol::CharacterSummaryInfo& _internal_characters(int index) const;
  ::Protocol::CharacterSummaryInfo* _internal_add_characters();
  public:
  const ::Protocol::CharacterSummaryInfo& characters(int index) const;
  ::Protocol::CharacterSummaryInfo* add_characters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::CharacterSummaryInfo >&
      characters() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_CharacterListReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::CharacterSummaryInfo > characters_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PlayerMoveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_PlayerMoveRequest) */ {
 public:
  inline C_PlayerMoveRequest() : C_PlayerMoveRequest(nullptr) {}
  ~C_PlayerMoveRequest() override;
  explicit PROTOBUF_CONSTEXPR C_PlayerMoveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PlayerMoveRequest(const C_PlayerMoveRequest& from);
  C_PlayerMoveRequest(C_PlayerMoveRequest&& from) noexcept
    : C_PlayerMoveRequest() {
    *this = ::std::move(from);
  }

  inline C_PlayerMoveRequest& operator=(const C_PlayerMoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PlayerMoveRequest& operator=(C_PlayerMoveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PlayerMoveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PlayerMoveRequest* internal_default_instance() {
    return reinterpret_cast<const C_PlayerMoveRequest*>(
               &_C_PlayerMoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(C_PlayerMoveRequest& a, C_PlayerMoveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PlayerMoveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PlayerMoveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PlayerMoveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PlayerMoveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_PlayerMoveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_PlayerMoveRequest& from) {
    C_PlayerMoveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_PlayerMoveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PlayerMoveRequest";
  }
  protected:
  explicit C_PlayerMoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClickWorldPosFieldNumber = 1,
  };
  // .Protocol.Vector2Info clickWorldPos = 1;
  bool has_clickworldpos() const;
  private:
  bool _internal_has_clickworldpos() const;
  public:
  void clear_clickworldpos();
  const ::Protocol::Vector2Info& clickworldpos() const;
  PROTOBUF_NODISCARD ::Protocol::Vector2Info* release_clickworldpos();
  ::Protocol::Vector2Info* mutable_clickworldpos();
  void set_allocated_clickworldpos(::Protocol::Vector2Info* clickworldpos);
  private:
  const ::Protocol::Vector2Info& _internal_clickworldpos() const;
  ::Protocol::Vector2Info* _internal_mutable_clickworldpos();
  public:
  void unsafe_arena_set_allocated_clickworldpos(
      ::Protocol::Vector2Info* clickworldpos);
  ::Protocol::Vector2Info* unsafe_arena_release_clickworldpos();

  // @@protoc_insertion_point(class_scope:Protocol.C_PlayerMoveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::Vector2Info* clickworldpos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_BroadcastPlayerMove final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_BroadcastPlayerMove) */ {
 public:
  inline S_BroadcastPlayerMove() : S_BroadcastPlayerMove(nullptr) {}
  ~S_BroadcastPlayerMove() override;
  explicit PROTOBUF_CONSTEXPR S_BroadcastPlayerMove(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_BroadcastPlayerMove(const S_BroadcastPlayerMove& from);
  S_BroadcastPlayerMove(S_BroadcastPlayerMove&& from) noexcept
    : S_BroadcastPlayerMove() {
    *this = ::std::move(from);
  }

  inline S_BroadcastPlayerMove& operator=(const S_BroadcastPlayerMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_BroadcastPlayerMove& operator=(S_BroadcastPlayerMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_BroadcastPlayerMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_BroadcastPlayerMove* internal_default_instance() {
    return reinterpret_cast<const S_BroadcastPlayerMove*>(
               &_S_BroadcastPlayerMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(S_BroadcastPlayerMove& a, S_BroadcastPlayerMove& b) {
    a.Swap(&b);
  }
  inline void Swap(S_BroadcastPlayerMove* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_BroadcastPlayerMove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_BroadcastPlayerMove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_BroadcastPlayerMove>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_BroadcastPlayerMove& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_BroadcastPlayerMove& from) {
    S_BroadcastPlayerMove::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_BroadcastPlayerMove* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_BroadcastPlayerMove";
  }
  protected:
  explicit S_BroadcastPlayerMove(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerMovesFieldNumber = 1,
  };
  // repeated .Protocol.PlayerMoveInfo playerMoves = 1;
  int playermoves_size() const;
  private:
  int _internal_playermoves_size() const;
  public:
  void clear_playermoves();
  ::Protocol::PlayerMoveInfo* mutable_playermoves(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerMoveInfo >*
      mutable_playermoves();
  private:
  const ::Protocol::PlayerMoveInfo& _internal_playermoves(int index) const;
  ::Protocol::PlayerMoveInfo* _internal_add_playermoves();
  public:
  const ::Protocol::PlayerMoveInfo& playermoves(int index) const;
  ::Protocol::PlayerMoveInfo* add_playermoves();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerMoveInfo >&
      playermoves() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_BroadcastPlayerMove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerMoveInfo > playermoves_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class Vector2Info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.Vector2Info) */ {
 public:
  inline Vector2Info() : Vector2Info(nullptr) {}
  ~Vector2Info() override;
  explicit PROTOBUF_CONSTEXPR Vector2Info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector2Info(const Vector2Info& from);
  Vector2Info(Vector2Info&& from) noexcept
    : Vector2Info() {
    *this = ::std::move(from);
  }

  inline Vector2Info& operator=(const Vector2Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector2Info& operator=(Vector2Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector2Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector2Info* internal_default_instance() {
    return reinterpret_cast<const Vector2Info*>(
               &_Vector2Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Vector2Info& a, Vector2Info& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector2Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector2Info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector2Info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector2Info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector2Info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vector2Info& from) {
    Vector2Info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector2Info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.Vector2Info";
  }
  protected:
  explicit Vector2Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.Vector2Info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t x_;
    int32_t y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class PlayerMoveInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PlayerMoveInfo) */ {
 public:
  inline PlayerMoveInfo() : PlayerMoveInfo(nullptr) {}
  ~PlayerMoveInfo() override;
  explicit PROTOBUF_CONSTEXPR PlayerMoveInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerMoveInfo(const PlayerMoveInfo& from);
  PlayerMoveInfo(PlayerMoveInfo&& from) noexcept
    : PlayerMoveInfo() {
    *this = ::std::move(from);
  }

  inline PlayerMoveInfo& operator=(const PlayerMoveInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerMoveInfo& operator=(PlayerMoveInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerMoveInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerMoveInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerMoveInfo*>(
               &_PlayerMoveInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PlayerMoveInfo& a, PlayerMoveInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerMoveInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerMoveInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerMoveInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerMoveInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerMoveInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerMoveInfo& from) {
    PlayerMoveInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerMoveInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PlayerMoveInfo";
  }
  protected:
  explicit PlayerMoveInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kDirectionFieldNumber = 2,
  };
  // int32 playerId = 1;
  void clear_playerid();
  int32_t playerid() const;
  void set_playerid(int32_t value);
  private:
  int32_t _internal_playerid() const;
  void _internal_set_playerid(int32_t value);
  public:

  // .Protocol.EDirection direction = 2;
  void clear_direction();
  ::Protocol::EDirection direction() const;
  void set_direction(::Protocol::EDirection value);
  private:
  ::Protocol::EDirection _internal_direction() const;
  void _internal_set_direction(::Protocol::EDirection value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PlayerMoveInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t playerid_;
    int direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CharacterSummaryInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CharacterSummaryInfo) */ {
 public:
  inline CharacterSummaryInfo() : CharacterSummaryInfo(nullptr) {}
  ~CharacterSummaryInfo() override;
  explicit PROTOBUF_CONSTEXPR CharacterSummaryInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CharacterSummaryInfo(const CharacterSummaryInfo& from);
  CharacterSummaryInfo(CharacterSummaryInfo&& from) noexcept
    : CharacterSummaryInfo() {
    *this = ::std::move(from);
  }

  inline CharacterSummaryInfo& operator=(const CharacterSummaryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterSummaryInfo& operator=(CharacterSummaryInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharacterSummaryInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CharacterSummaryInfo* internal_default_instance() {
    return reinterpret_cast<const CharacterSummaryInfo*>(
               &_CharacterSummaryInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CharacterSummaryInfo& a, CharacterSummaryInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CharacterSummaryInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterSummaryInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharacterSummaryInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CharacterSummaryInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CharacterSummaryInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CharacterSummaryInfo& from) {
    CharacterSummaryInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CharacterSummaryInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CharacterSummaryInfo";
  }
  protected:
  explicit CharacterSummaryInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kLevelFieldNumber = 2,
    kGenderFieldNumber = 3,
    kRegionFieldNumber = 4,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // int32 level = 2;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // .Protocol.EGender gender = 3;
  void clear_gender();
  ::Protocol::EGender gender() const;
  void set_gender(::Protocol::EGender value);
  private:
  ::Protocol::EGender _internal_gender() const;
  void _internal_set_gender(::Protocol::EGender value);
  public:

  // .Protocol.ERegion region = 4;
  void clear_region();
  ::Protocol::ERegion region() const;
  void set_region(::Protocol::ERegion value);
  private:
  ::Protocol::ERegion _internal_region() const;
  void _internal_set_region(::Protocol::ERegion value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CharacterSummaryInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    int32_t level_;
    int gender_;
    int region_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// C_JwtLoginRequest

// string accessToken = 1;
inline void C_JwtLoginRequest::clear_accesstoken() {
  _impl_.accesstoken_.ClearToEmpty();
}
inline const std::string& C_JwtLoginRequest::accesstoken() const {
  // @@protoc_insertion_point(field_get:Protocol.C_JwtLoginRequest.accessToken)
  return _internal_accesstoken();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_JwtLoginRequest::set_accesstoken(ArgT0&& arg0, ArgT... args) {
 
 _impl_.accesstoken_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_JwtLoginRequest.accessToken)
}
inline std::string* C_JwtLoginRequest::mutable_accesstoken() {
  std::string* _s = _internal_mutable_accesstoken();
  // @@protoc_insertion_point(field_mutable:Protocol.C_JwtLoginRequest.accessToken)
  return _s;
}
inline const std::string& C_JwtLoginRequest::_internal_accesstoken() const {
  return _impl_.accesstoken_.Get();
}
inline void C_JwtLoginRequest::_internal_set_accesstoken(const std::string& value) {
  
  _impl_.accesstoken_.Set(value, GetArenaForAllocation());
}
inline std::string* C_JwtLoginRequest::_internal_mutable_accesstoken() {
  
  return _impl_.accesstoken_.Mutable(GetArenaForAllocation());
}
inline std::string* C_JwtLoginRequest::release_accesstoken() {
  // @@protoc_insertion_point(field_release:Protocol.C_JwtLoginRequest.accessToken)
  return _impl_.accesstoken_.Release();
}
inline void C_JwtLoginRequest::set_allocated_accesstoken(std::string* accesstoken) {
  if (accesstoken != nullptr) {
    
  } else {
    
  }
  _impl_.accesstoken_.SetAllocated(accesstoken, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.accesstoken_.IsDefault()) {
    _impl_.accesstoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_JwtLoginRequest.accessToken)
}

// -------------------------------------------------------------------

// S_JwtLoginReply

// .Protocol.ELoginResult result = 1;
inline void S_JwtLoginReply::clear_result() {
  _impl_.result_ = 0;
}
inline ::Protocol::ELoginResult S_JwtLoginReply::_internal_result() const {
  return static_cast< ::Protocol::ELoginResult >(_impl_.result_);
}
inline ::Protocol::ELoginResult S_JwtLoginReply::result() const {
  // @@protoc_insertion_point(field_get:Protocol.S_JwtLoginReply.result)
  return _internal_result();
}
inline void S_JwtLoginReply::_internal_set_result(::Protocol::ELoginResult value) {
  
  _impl_.result_ = value;
}
inline void S_JwtLoginReply::set_result(::Protocol::ELoginResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Protocol.S_JwtLoginReply.result)
}

// -------------------------------------------------------------------

// C_CreateCharacterRequest

// string username = 1;
inline void C_CreateCharacterRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& C_CreateCharacterRequest::username() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CreateCharacterRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CreateCharacterRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CreateCharacterRequest.username)
}
inline std::string* C_CreateCharacterRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:Protocol.C_CreateCharacterRequest.username)
  return _s;
}
inline const std::string& C_CreateCharacterRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void C_CreateCharacterRequest::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* C_CreateCharacterRequest::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* C_CreateCharacterRequest::release_username() {
  // @@protoc_insertion_point(field_release:Protocol.C_CreateCharacterRequest.username)
  return _impl_.username_.Release();
}
inline void C_CreateCharacterRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CreateCharacterRequest.username)
}

// .Protocol.EGender gender = 2;
inline void C_CreateCharacterRequest::clear_gender() {
  _impl_.gender_ = 0;
}
inline ::Protocol::EGender C_CreateCharacterRequest::_internal_gender() const {
  return static_cast< ::Protocol::EGender >(_impl_.gender_);
}
inline ::Protocol::EGender C_CreateCharacterRequest::gender() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CreateCharacterRequest.gender)
  return _internal_gender();
}
inline void C_CreateCharacterRequest::_internal_set_gender(::Protocol::EGender value) {
  
  _impl_.gender_ = value;
}
inline void C_CreateCharacterRequest::set_gender(::Protocol::EGender value) {
  _internal_set_gender(value);
  // @@protoc_insertion_point(field_set:Protocol.C_CreateCharacterRequest.gender)
}

// .Protocol.ERegion region = 3;
inline void C_CreateCharacterRequest::clear_region() {
  _impl_.region_ = 0;
}
inline ::Protocol::ERegion C_CreateCharacterRequest::_internal_region() const {
  return static_cast< ::Protocol::ERegion >(_impl_.region_);
}
inline ::Protocol::ERegion C_CreateCharacterRequest::region() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CreateCharacterRequest.region)
  return _internal_region();
}
inline void C_CreateCharacterRequest::_internal_set_region(::Protocol::ERegion value) {
  
  _impl_.region_ = value;
}
inline void C_CreateCharacterRequest::set_region(::Protocol::ERegion value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:Protocol.C_CreateCharacterRequest.region)
}

// -------------------------------------------------------------------

// S_CreateCharacterReply

// bool success = 1;
inline void S_CreateCharacterReply::clear_success() {
  _impl_.success_ = false;
}
inline bool S_CreateCharacterReply::_internal_success() const {
  return _impl_.success_;
}
inline bool S_CreateCharacterReply::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CreateCharacterReply.success)
  return _internal_success();
}
inline void S_CreateCharacterReply::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_CreateCharacterReply::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CreateCharacterReply.success)
}

// string detail = 2;
inline void S_CreateCharacterReply::clear_detail() {
  _impl_.detail_.ClearToEmpty();
}
inline const std::string& S_CreateCharacterReply::detail() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CreateCharacterReply.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_CreateCharacterReply::set_detail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.detail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_CreateCharacterReply.detail)
}
inline std::string* S_CreateCharacterReply::mutable_detail() {
  std::string* _s = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CreateCharacterReply.detail)
  return _s;
}
inline const std::string& S_CreateCharacterReply::_internal_detail() const {
  return _impl_.detail_.Get();
}
inline void S_CreateCharacterReply::_internal_set_detail(const std::string& value) {
  
  _impl_.detail_.Set(value, GetArenaForAllocation());
}
inline std::string* S_CreateCharacterReply::_internal_mutable_detail() {
  
  return _impl_.detail_.Mutable(GetArenaForAllocation());
}
inline std::string* S_CreateCharacterReply::release_detail() {
  // @@protoc_insertion_point(field_release:Protocol.S_CreateCharacterReply.detail)
  return _impl_.detail_.Release();
}
inline void S_CreateCharacterReply::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    
  } else {
    
  }
  _impl_.detail_.SetAllocated(detail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detail_.IsDefault()) {
    _impl_.detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CreateCharacterReply.detail)
}

// -------------------------------------------------------------------

// C_CharacterListRequest

// -------------------------------------------------------------------

// S_CharacterListReply

// repeated .Protocol.CharacterSummaryInfo characters = 1;
inline int S_CharacterListReply::_internal_characters_size() const {
  return _impl_.characters_.size();
}
inline int S_CharacterListReply::characters_size() const {
  return _internal_characters_size();
}
inline void S_CharacterListReply::clear_characters() {
  _impl_.characters_.Clear();
}
inline ::Protocol::CharacterSummaryInfo* S_CharacterListReply::mutable_characters(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_CharacterListReply.characters)
  return _impl_.characters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::CharacterSummaryInfo >*
S_CharacterListReply::mutable_characters() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_CharacterListReply.characters)
  return &_impl_.characters_;
}
inline const ::Protocol::CharacterSummaryInfo& S_CharacterListReply::_internal_characters(int index) const {
  return _impl_.characters_.Get(index);
}
inline const ::Protocol::CharacterSummaryInfo& S_CharacterListReply::characters(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_CharacterListReply.characters)
  return _internal_characters(index);
}
inline ::Protocol::CharacterSummaryInfo* S_CharacterListReply::_internal_add_characters() {
  return _impl_.characters_.Add();
}
inline ::Protocol::CharacterSummaryInfo* S_CharacterListReply::add_characters() {
  ::Protocol::CharacterSummaryInfo* _add = _internal_add_characters();
  // @@protoc_insertion_point(field_add:Protocol.S_CharacterListReply.characters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::CharacterSummaryInfo >&
S_CharacterListReply::characters() const {
  // @@protoc_insertion_point(field_list:Protocol.S_CharacterListReply.characters)
  return _impl_.characters_;
}

// -------------------------------------------------------------------

// C_PlayerMoveRequest

// .Protocol.Vector2Info clickWorldPos = 1;
inline bool C_PlayerMoveRequest::_internal_has_clickworldpos() const {
  return this != internal_default_instance() && _impl_.clickworldpos_ != nullptr;
}
inline bool C_PlayerMoveRequest::has_clickworldpos() const {
  return _internal_has_clickworldpos();
}
inline void C_PlayerMoveRequest::clear_clickworldpos() {
  if (GetArenaForAllocation() == nullptr && _impl_.clickworldpos_ != nullptr) {
    delete _impl_.clickworldpos_;
  }
  _impl_.clickworldpos_ = nullptr;
}
inline const ::Protocol::Vector2Info& C_PlayerMoveRequest::_internal_clickworldpos() const {
  const ::Protocol::Vector2Info* p = _impl_.clickworldpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector2Info&>(
      ::Protocol::_Vector2Info_default_instance_);
}
inline const ::Protocol::Vector2Info& C_PlayerMoveRequest::clickworldpos() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PlayerMoveRequest.clickWorldPos)
  return _internal_clickworldpos();
}
inline void C_PlayerMoveRequest::unsafe_arena_set_allocated_clickworldpos(
    ::Protocol::Vector2Info* clickworldpos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clickworldpos_);
  }
  _impl_.clickworldpos_ = clickworldpos;
  if (clickworldpos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_PlayerMoveRequest.clickWorldPos)
}
inline ::Protocol::Vector2Info* C_PlayerMoveRequest::release_clickworldpos() {
  
  ::Protocol::Vector2Info* temp = _impl_.clickworldpos_;
  _impl_.clickworldpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Vector2Info* C_PlayerMoveRequest::unsafe_arena_release_clickworldpos() {
  // @@protoc_insertion_point(field_release:Protocol.C_PlayerMoveRequest.clickWorldPos)
  
  ::Protocol::Vector2Info* temp = _impl_.clickworldpos_;
  _impl_.clickworldpos_ = nullptr;
  return temp;
}
inline ::Protocol::Vector2Info* C_PlayerMoveRequest::_internal_mutable_clickworldpos() {
  
  if (_impl_.clickworldpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector2Info>(GetArenaForAllocation());
    _impl_.clickworldpos_ = p;
  }
  return _impl_.clickworldpos_;
}
inline ::Protocol::Vector2Info* C_PlayerMoveRequest::mutable_clickworldpos() {
  ::Protocol::Vector2Info* _msg = _internal_mutable_clickworldpos();
  // @@protoc_insertion_point(field_mutable:Protocol.C_PlayerMoveRequest.clickWorldPos)
  return _msg;
}
inline void C_PlayerMoveRequest::set_allocated_clickworldpos(::Protocol::Vector2Info* clickworldpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.clickworldpos_;
  }
  if (clickworldpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clickworldpos);
    if (message_arena != submessage_arena) {
      clickworldpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clickworldpos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.clickworldpos_ = clickworldpos;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_PlayerMoveRequest.clickWorldPos)
}

// -------------------------------------------------------------------

// S_BroadcastPlayerMove

// repeated .Protocol.PlayerMoveInfo playerMoves = 1;
inline int S_BroadcastPlayerMove::_internal_playermoves_size() const {
  return _impl_.playermoves_.size();
}
inline int S_BroadcastPlayerMove::playermoves_size() const {
  return _internal_playermoves_size();
}
inline void S_BroadcastPlayerMove::clear_playermoves() {
  _impl_.playermoves_.Clear();
}
inline ::Protocol::PlayerMoveInfo* S_BroadcastPlayerMove::mutable_playermoves(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_BroadcastPlayerMove.playerMoves)
  return _impl_.playermoves_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerMoveInfo >*
S_BroadcastPlayerMove::mutable_playermoves() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_BroadcastPlayerMove.playerMoves)
  return &_impl_.playermoves_;
}
inline const ::Protocol::PlayerMoveInfo& S_BroadcastPlayerMove::_internal_playermoves(int index) const {
  return _impl_.playermoves_.Get(index);
}
inline const ::Protocol::PlayerMoveInfo& S_BroadcastPlayerMove::playermoves(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastPlayerMove.playerMoves)
  return _internal_playermoves(index);
}
inline ::Protocol::PlayerMoveInfo* S_BroadcastPlayerMove::_internal_add_playermoves() {
  return _impl_.playermoves_.Add();
}
inline ::Protocol::PlayerMoveInfo* S_BroadcastPlayerMove::add_playermoves() {
  ::Protocol::PlayerMoveInfo* _add = _internal_add_playermoves();
  // @@protoc_insertion_point(field_add:Protocol.S_BroadcastPlayerMove.playerMoves)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerMoveInfo >&
S_BroadcastPlayerMove::playermoves() const {
  // @@protoc_insertion_point(field_list:Protocol.S_BroadcastPlayerMove.playerMoves)
  return _impl_.playermoves_;
}

// -------------------------------------------------------------------

// Vector2Info

// int32 x = 1;
inline void Vector2Info::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t Vector2Info::_internal_x() const {
  return _impl_.x_;
}
inline int32_t Vector2Info::x() const {
  // @@protoc_insertion_point(field_get:Protocol.Vector2Info.x)
  return _internal_x();
}
inline void Vector2Info::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void Vector2Info::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.Vector2Info.x)
}

// int32 y = 2;
inline void Vector2Info::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t Vector2Info::_internal_y() const {
  return _impl_.y_;
}
inline int32_t Vector2Info::y() const {
  // @@protoc_insertion_point(field_get:Protocol.Vector2Info.y)
  return _internal_y();
}
inline void Vector2Info::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void Vector2Info::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.Vector2Info.y)
}

// -------------------------------------------------------------------

// PlayerMoveInfo

// int32 playerId = 1;
inline void PlayerMoveInfo::clear_playerid() {
  _impl_.playerid_ = 0;
}
inline int32_t PlayerMoveInfo::_internal_playerid() const {
  return _impl_.playerid_;
}
inline int32_t PlayerMoveInfo::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerMoveInfo.playerId)
  return _internal_playerid();
}
inline void PlayerMoveInfo::_internal_set_playerid(int32_t value) {
  
  _impl_.playerid_ = value;
}
inline void PlayerMoveInfo::set_playerid(int32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerMoveInfo.playerId)
}

// .Protocol.EDirection direction = 2;
inline void PlayerMoveInfo::clear_direction() {
  _impl_.direction_ = 0;
}
inline ::Protocol::EDirection PlayerMoveInfo::_internal_direction() const {
  return static_cast< ::Protocol::EDirection >(_impl_.direction_);
}
inline ::Protocol::EDirection PlayerMoveInfo::direction() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerMoveInfo.direction)
  return _internal_direction();
}
inline void PlayerMoveInfo::_internal_set_direction(::Protocol::EDirection value) {
  
  _impl_.direction_ = value;
}
inline void PlayerMoveInfo::set_direction(::Protocol::EDirection value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerMoveInfo.direction)
}

// -------------------------------------------------------------------

// CharacterSummaryInfo

// string username = 1;
inline void CharacterSummaryInfo::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& CharacterSummaryInfo::username() const {
  // @@protoc_insertion_point(field_get:Protocol.CharacterSummaryInfo.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CharacterSummaryInfo::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CharacterSummaryInfo.username)
}
inline std::string* CharacterSummaryInfo::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:Protocol.CharacterSummaryInfo.username)
  return _s;
}
inline const std::string& CharacterSummaryInfo::_internal_username() const {
  return _impl_.username_.Get();
}
inline void CharacterSummaryInfo::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* CharacterSummaryInfo::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* CharacterSummaryInfo::release_username() {
  // @@protoc_insertion_point(field_release:Protocol.CharacterSummaryInfo.username)
  return _impl_.username_.Release();
}
inline void CharacterSummaryInfo::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CharacterSummaryInfo.username)
}

// int32 level = 2;
inline void CharacterSummaryInfo::clear_level() {
  _impl_.level_ = 0;
}
inline int32_t CharacterSummaryInfo::_internal_level() const {
  return _impl_.level_;
}
inline int32_t CharacterSummaryInfo::level() const {
  // @@protoc_insertion_point(field_get:Protocol.CharacterSummaryInfo.level)
  return _internal_level();
}
inline void CharacterSummaryInfo::_internal_set_level(int32_t value) {
  
  _impl_.level_ = value;
}
inline void CharacterSummaryInfo::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Protocol.CharacterSummaryInfo.level)
}

// .Protocol.EGender gender = 3;
inline void CharacterSummaryInfo::clear_gender() {
  _impl_.gender_ = 0;
}
inline ::Protocol::EGender CharacterSummaryInfo::_internal_gender() const {
  return static_cast< ::Protocol::EGender >(_impl_.gender_);
}
inline ::Protocol::EGender CharacterSummaryInfo::gender() const {
  // @@protoc_insertion_point(field_get:Protocol.CharacterSummaryInfo.gender)
  return _internal_gender();
}
inline void CharacterSummaryInfo::_internal_set_gender(::Protocol::EGender value) {
  
  _impl_.gender_ = value;
}
inline void CharacterSummaryInfo::set_gender(::Protocol::EGender value) {
  _internal_set_gender(value);
  // @@protoc_insertion_point(field_set:Protocol.CharacterSummaryInfo.gender)
}

// .Protocol.ERegion region = 4;
inline void CharacterSummaryInfo::clear_region() {
  _impl_.region_ = 0;
}
inline ::Protocol::ERegion CharacterSummaryInfo::_internal_region() const {
  return static_cast< ::Protocol::ERegion >(_impl_.region_);
}
inline ::Protocol::ERegion CharacterSummaryInfo::region() const {
  // @@protoc_insertion_point(field_get:Protocol.CharacterSummaryInfo.region)
  return _internal_region();
}
inline void CharacterSummaryInfo::_internal_set_region(::Protocol::ERegion value) {
  
  _impl_.region_ = value;
}
inline void CharacterSummaryInfo::set_region(::Protocol::ERegion value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:Protocol.CharacterSummaryInfo.region)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Protocol::MsgId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::MsgId>() {
  return ::Protocol::MsgId_descriptor();
}
template <> struct is_proto_enum< ::Protocol::ELoginResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::ELoginResult>() {
  return ::Protocol::ELoginResult_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EGender> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EGender>() {
  return ::Protocol::EGender_descriptor();
}
template <> struct is_proto_enum< ::Protocol::ERegion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::ERegion>() {
  return ::Protocol::ERegion_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EDirection>() {
  return ::Protocol::EDirection_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
